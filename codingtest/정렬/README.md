### 정렬 알고리즘

<br />

## 정렬 알고리즘 개요

<br/>

### 정렬 (Sorting)
- 데이터를 특정한 기준에 따라서 순서대로 나열하는 것
- 정렬 알고리즘은 프로그램을 작성할 때 가장 많이 사용되는 알고리즘 중 하나
- 정렬 알고리즘으로 데이터를 정렬하면 '이진 탐색(Binary Search)'가 가능하다.
- 정렬 알고리즘을 공부하면 '알고리즘의 효율성'을 쉽게 이해할 수 있다.

<br/>

## 선택 정렬
- 데이터가 무작위로 여러 개 있을 때, 가장 작은 데이터를 선택해서 앞으로 보내는 과정을 반복해서 수행하여 전체 데이터의 정렬을 이루는 것

<br/>

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i
    for j in range(i+1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i]
    print(array)

print(array)

# [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]
# [0, 5, 9, 7, 3, 1, 6, 2, 4, 8]
# [0, 1, 9, 7, 3, 5, 6, 2, 4, 8]
# [0, 1, 2, 7, 3, 5, 6, 9, 4, 8]
# [0, 1, 2, 3, 7, 5, 6, 9, 4, 8]
# [0, 1, 2, 3, 4, 5, 6, 9, 7, 8]
# [0, 1, 2, 3, 4, 5, 6, 9, 7, 8]
# [0, 1, 2, 3, 4, 5, 6, 9, 7, 8]
# [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

- 선택 정렬은 전체 데이터의 개수가 N일 때, 가장 작은 데이터를 앞으로 보내는 과정을 N - 1번 반복하면 정렬이 완료되는 것을 알 수 있다.

<br/>

### 선택 정렬의 시간 복잡도
- 선택 정렬은 N - 1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.
- 또한 매번 가장 작은 수를 찾기 위해서 비교 연산이 필요하다.
- 따라서, 연산 횟수는 N x (N + 1) / 2번의 연산을 수행한다고 가정하면 빅오 표기법으로 간단히 O(N^2)로 표현할 수 있다.
- 선택 정렬은 다른 정렬 알고리즘과 기본 정렬 라이브러리와 비교했을 때, 매우 비효율적인 편이다.

<br/>

## 삽입 정렬
- 삽입 정렬은 선택 정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘으로 잘 알려져있다.
- 삽입 정렬은 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적이다.
- 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정하고 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 후에, 그 위치에 삽입된다.

<br/>

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1):
        if array[j] < array[j-1]:
            array[j], array[j-1] = array[j-1], array[j]
        else:
            break
        print(array)

# [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]
# [5, 7, 0, 9, 3, 1, 6, 2, 4, 8]
# [5, 0, 7, 9, 3, 1, 6, 2, 4, 8]
# [0, 5, 7, 9, 3, 1, 6, 2, 4, 8]
# [0, 5, 7, 3, 9, 1, 6, 2, 4, 8]
# [0, 5, 3, 7, 9, 1, 6, 2, 4, 8]
# [0, 3, 5, 7, 9, 1, 6, 2, 4, 8]
# [0, 3, 5, 7, 1, 9, 6, 2, 4, 8]
# [0, 3, 5, 1, 7, 9, 6, 2, 4, 8]
# [0, 3, 1, 5, 7, 9, 6, 2, 4, 8]
# [0, 1, 3, 5, 7, 9, 6, 2, 4, 8]
# [0, 1, 3, 5, 7, 6, 9, 2, 4, 8]
# [0, 1, 3, 5, 6, 7, 9, 2, 4, 8]
# [0, 1, 3, 5, 6, 7, 2, 9, 4, 8]
# [0, 1, 3, 5, 6, 2, 7, 9, 4, 8]
# [0, 1, 3, 5, 2, 6, 7, 9, 4, 8]
# [0, 1, 3, 2, 5, 6, 7, 9, 4, 8]
# [0, 1, 2, 3, 5, 6, 7, 9, 4, 8]
# [0, 1, 2, 3, 5, 6, 7, 4, 9, 8]
# [0, 1, 2, 3, 5, 6, 4, 7, 9, 8]
# [0, 1, 2, 3, 5, 4, 6, 7, 9, 8]
# [0, 1, 2, 3, 4, 5, 6, 7, 9, 8]
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

<br/>

### 삽입 정렬의 시간 복잡도
- 삽입 정렬의 시간 복잡도는 선택 정렬과 마찬가지로 반복문이 2번 중첩되어 사용되었기 때문에, O(N^2)
- 삽입 정렬에서 기억해야 할 내용은 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작하여, 최선의 경우 시간 복잡도 O(N)을 갖는다.
- 보통은 삽입 정렬이 비효율적이나, 정렬이 거의 되어 있는 상황에서는 퀵 정렬 알고리즘보다 효율적이다.

<br/>

## 퀵 정렬
- 퀵 정렬은 가장 많이 사용되는 정렬 알고리즘이다.
- 퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후, 리스트를 반으로 나누는 방식으로 동작한다.
- 퀵 정렬에서는 Pivot이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 Pivot이라고 표현한다.
- Pivot을 설정하고 리스트를 분할하는 방법은 여러 가지 방식이 있지만, 가장 대표적인 분할 방식인 호어 분할(Hoare Partition) 방식을 기준으로 설명하면 Pivot을 설정하고 왼쪽에서부터 Pivot보다 큰 데이터를 찾고, 오른쪽에서부터 Pivot보다 작은 데이터를 찾는다. 그리고 다음에 큰 데이터와 작은 데이터의 위치를 서로 교환해주는 과정을 반복하면 Pivot에 대하여 정렬이 수행된다.

<br/>

```python
# 퀵 정렬 1

array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end:
        return
    
    pivot = start
    left = start + 1
    right = end

    while left <= right:
        while left <= end and array[left] <= array[pivot]:
            left += 1
        while right > start and array[right] >= array[pivot]:
            right -= 1
        if left > right:
            array[right], array[pivot] = array[pivot], array[right]
        else:
            array[left], array[right] = array[right], array[left]
        print(array)

    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)

# [5, 4, 9, 0, 3, 1, 6, 2, 7, 8]
# [5, 4, 2, 0, 3, 1, 6, 9, 7, 8]
# [1, 4, 2, 0, 3, 5, 6, 9, 7, 8]
# [1, 0, 2, 4, 3, 5, 6, 9, 7, 8]
# [0, 1, 2, 4, 3, 5, 6, 9, 7, 8]
# [0, 1, 2, 4, 3, 5, 6, 9, 7, 8]
# [0, 1, 2, 3, 4, 5, 6, 9, 7, 8]
# [0, 1, 2, 3, 4, 5, 6, 9, 7, 8]
# [0, 1, 2, 3, 4, 5, 6, 8, 7, 9]
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

<br/>

```python
# 퀵 정렬 2

array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    # 리스트의 원소가 1개 이하의 원소만을 담고 있다면 종료
    if len(array) <= 1:
        return array
    
    # pivot은 첫 번째 원소로 지정
    pivot = array[0]
    # pivot을 제외한 나머지 리스트
    tail = array[1:]

    # pivot 보다 작거나 같은 수를 담는 pivot을 기준으로 분할된 왼쪽 리스트
    left_side = [x for x in tail if x <= pivot]
    # pivot 보다 큰 수를 담는 pivot을 기준으로 분할된 오른쪽 리스트
    right_side = [x for x in tail if x > pivot]

    print(left_side + [pivot] + right_side)

    # 분할된 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬을 수행하고, 전체 리스트 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))

# [0, 3, 1, 2, 4, 5, 7, 9, 6, 8]
# [0, 3, 1, 2, 4]
# [1, 2, 3, 4]
# [1, 2]
# [6, 7, 9, 8]
# [8, 9]
# [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

<br/>

### 퀵 정렬의 시간 복잡도
- 퀵 정렬의 평균 시간 복잡도는 O(NlogN)으로, 선택 정렬과 삽입 정렬에 비해 매우 빠른 편이다. 하지만 최악의 경우 시간 복잡도는 O(N^2)이다.
- 삽입 정렬은 데이터가 이미 정렬되어 있는 경우, 알고리즘의 효율성이 극대화되는 반면에 퀵 정렬은 데이터가 이미 정렬되어 있는 경우에는 매우 느리게 동작하게 된다.